/*

< B tree >

이진 탐색 트리에서 발전된 형태로 노드에 여러 개의 데이터가 들어 갈 수 있다. 
이 때 하나의 노드에 들어갈 수 있는 최대 노드 수를 m개라 할 때 루트를 제외한 노드는 m/2개의 데이터를 최소한으로 가져야 하며, 하나의 노드는 최대 m+1개의 자식노드를 가져야 한다.

탐색은 이진 탐색 트리와 동일한 방식으로 이루어지며 O( logm+1 N ) 시간이 걸리기 때문에 BST에 비해 성능이 매우 향상 됨을 알 수 있다. 
삽입은 탐색을 하여 리프노드에서 들어갈 자리를 찾은 후 최대 갯수가 이미 차 있으면 하나를 부모 노드로 올린다. 이때 부모 노드의 데이터 수가 최대 갯수를 넘어가게 되면 분할 하여 노드를 나누어 준다. 
       이런 방식으로 아래에서 위로 올라가는 상향식으로 트리가 구성되게 된다. 
삭제는 탐색을 하여 데이터값이 들어있는 노드를 찾은 후 삭제 하는데 m/2개의 데이터를 최소한으로 가져야 하므로( 소수점 내림 적용 ) 해당 조건을 만족하지 못한다면 형제노드와 병합해준다. 

DB, 파일 시스템에 많이 사용된다. 

단 : 순차 탐색을 할 경우 B+보다 성능이 떨어진다. 블록 단위로 불러오기 때문에 2 byte를 가져오기 위해 1024 byte를 불러와야하는 비효율이 발생한다. 


< B+ tree >

B 트리의 특징을 가지고 있는데 B 트리와의 차이점은 리프 노드를 제외한 나머지 노드는 리프 노드의 키값만을 가지고 있다는 점이다. 
모든 데이터는 리프 노드에 정렬되어 존재하며 리프 노드들을 링크드 리스트로 연결 되어있다. 
삽입, 탐색은 O(log n)의 시간이 걸리며 삭제 시 B트리와 동일하지만 키 값이 삭제 되는 경우 부모 혹은 조상 노드를 갱신한다. 



장점 : 리프노드에 모든 데이터가 존재하고 정렬되어 링크드 리스트로 연결되어 있기 때문에 순차적인 데이터 접근에 매우 유리하다. 연속적인 데이터에 접근 할 경우 탐색 과정을 여러번 거치지 않아도 된다. 
단점 : 키 값이 날라가는 경우 그 노드의 데이터에 접근의 효율이 떨어질 수 있다. 


*/